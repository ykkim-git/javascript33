/**
 * Big O: 입력 시간에 따라 알고리즘이 실행되는 데 걸리는 시간을 수학적으로 표기한 것
 알고리즘의 전체 단계를 대수로 바꾸고 전체 복잡성에 큰 영향을 미치지않는
 하위 상수 및 계수를 제외한다.

Regular       Big-O
2             O(1)   --> It's just a constant number
2n + 10       O(n)   --> n has the largest effect
5n^2          O(n^2) --> n^2 has the largest effect
 */

/**
 * 1. O(1) - constant time
 데이터의 크기와 상관 없이 언제나 일정한 시간이 걸리는 알고리즘

 * 2. O(n) - linear time
 입력 데이터의 크기에 비례해서 처리시간이 걸리는 알고리즘

 * 3. O(n2) - quadratic time
 보통 n개의 데이터를 loop돌리면서 그 안쪽에 n번 만큼의 loop를 한번 더 돌리면
 O(n2)의 시간복잡도의 알고리즘이라고 표현한다.

 * 4. O(nm) - quadratic time (n의 m승)
 위 O(n2)의 2개의 변수 버전

 * 5. O(n3) - polynomial / cubic time (n의 3승)
 위 O(n2)의 세제곱이며 가로 세로 높이까지 추가된 시간복잡도로써 
 데이터가 늘어나면 O(n2)보다 처리시간이 더욱 급격하게 올라가게 된다.

 * 6. O(2n) - exponential time (2의 n승)
 피보나치 수열 알고리즘을 재귀 형식으로 구현하면 O(2n)의 시간복잡도를 갖는다.
 O(n3)보다 데이터가 추가됨에 따른 처리 시간이 더욱 급격하게 올라간다.

 * 7. O(log n)
 오름차순으로 정렬된 숫자 배열에서 특정 수를 binary search로 찾는 알고리즘이
 대표적인 O(log n) 알고리즘이다. 한번 처리가 진행 될 때마다 검색해야 하는
 데이터의 양이 반씩 떨어지는 알고리즘을 O(log n)이라 한다. O(n)보다 효율적이라서
 데이터가 늘어나도 성능이 크게 차이가 안 난다!

 * 8. O(sqrt(n))
 O(n) 알고리즘에서 데이터 양의 제곱근의 순회만으로 풀리는 알고리즘이다.
 예를들어 숫자 36의 약수를 구하는 알고리즘을 1부터 36까지 모두 확인하면 O(n)이지만
 약수가 대칭성을 보인다는 특징을 이용하면 36의 제곱근인 6번만의 순회만으로도
 36의 약수를 모두 구할 수 있게 된다.

 */
